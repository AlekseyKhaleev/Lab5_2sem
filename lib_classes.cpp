/*********************************************************************************************************************
* Данный модуль содержит определения иерархии классов, предназначенных для работы с таблицей данных отдела кадров
* (приложение Lab5-2)
*********************************************************************************************************************/

/* Подключение модулей */
#include "lib_classes.h"
#include <string>
#include <iostream>
#include <vector>
#include <cstring>
#include "lib_exceptions.h"

using namespace Person_const;
/**********************************************************************************************************************
*                                                class IPerson
***********************************************************************************************************************/

PrsPtr IPerson::CreateInstance(int id) {
    /*******************************************************************************************************************
    * Цель: создание экземпляра производного к IPerson класса
    * Исходные данные:
    *      id - целочисленный идентификатор, содержащий данные о принадлежности к конечному производному классу
    * Результат:
    *   Возврат умного указателя на экземпляр нужного производного класса
    * Вызываемые модули: <memory>
    * Описание алгоритма:
    *  Идентификатор состоит из 5-значного целого числа, первые 2 цифры которого соответствуют конечному классу,
    * являющимся производным от IPerson
    * 1) С помощью операции взятия остатка от деления id на 1000 получаем данные о классе, экземпляр которого необходимо
    * создать.
    * 2) С помощью умного указателя создаем экземпляр нужного класса.
    * 3) Возвращаем указатель на созданный экземпляр класса.
    * В случае если запрошенного класса не существует вызываем соответствующее исключение класса SyntaxException
    * Дата: 07 / 06 / 2022 Версия 1.01
    * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    * Исправления: нет
    *******************************************************************************************************************/
    switch (id / 1000) { // получаем 2 первые цифры ID
        case 11:
            return std::make_shared<Teacher>();  // возврат умного указателя на экземпляр класса Teacher
        case 12:
            return std::make_shared<Assistant>();// возврат умного указателя на экземпляр класса Assistant
        case 13:
            return std::make_shared<HouseKeeper>();// возврат умного указателя на экземпляр класса HouseKeeper
        case 21:
            return std::make_shared<Bachelor>();// возврат умного указателя на экземпляр класса Bachelor
        case 22:
            return std::make_shared<Master>();// возврат умного указателя на экземпляр класса Master
        case 23:
            return std::make_shared<Graduate>();// возврат умного указателя на экземпляр класса Graduate
        default:
            throw SyntaxException("Enter correct ID or press 'h' for help", 10); // вызов исключения
    }
}

PrsPtr IPerson::InitInstance(int row_to_print) {
    /*******************************************************************************************************************
    * Цель: создание экземпляра производного к IPerson класса и инициализация атрибутов в необходимых ячейках таблицы
    * Исходные данные:
    *      row_to_print - номер строки в которой визуально производится ввод данных в таблице
    * Результат:
    *   Возврат умного указателя на экземпляр нужного производного класса
    * Вызываемые модули: <memory>, <vector>, <string>, "liblibrary.a"
    * Описание алгоритма:
    * 1) Объявляется умный указатель ptr типа IPerson;
    * 2) Объявляется статический член метода(функции) IDs - контейнер стандартной библиотеки <vector>. Он предназначен
    * для хранения ID сотрудников и студентов уже записанных в таблицу.
    * 3) В бесконечном цикле производится попытка создать экземпляр нужного класса:
    *   - пользователь вводит ID;
    *   - производятся проверки на корректность введенного ID, в случае неверного ввода вызывается исключение
    *   - с помощью метода CreateInstance создается экземпляр нужного класса, указатель на экземпляр присваивается ptr
    * 4) id добавляется в конец вектора IDs
    * 5) В соответствующих ячейках производится инициализация/вывод очередного атрибута
    * 6) Возвращается указатель на инициализированный класс ptr
    * В случае если запрошенного класса не существует вызываем соответствующее исключение класса SyntaxException
    * Дата: 07 / 06 / 2022 Версия 1.01
    * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    * Исправления: нет
    *******************************************************************************************************************/

    static std::vector<int> IDs; // статический контейнер для хранения учтенных ID сотрудников
    int current_col{START_COL}, int_id;
    string id;
    PrsPtr ptr;
    while (ptr == nullptr) {
        try {
            move_cursor(START_ROW + row_to_print * STEP_ROW, START_COL); // перемещение курсора в нужную позицию
            std::cin >> id; // ввод табельного номера
            try {
                int_id = std::stoi(id); // попытка привести к целому типу полученного аргумента
            } catch (std::exception &stoi_err) {
                throw SyntaxException("Wrong ID syntax, it's must be an integer", 10);
            }
            if (id.size() != 5) { // табельный номер должен содержать 5 символов
                throw SyntaxException("Wrong ID syntax, run app with '-h' flag to learn more", 10);
            }
            for (auto &elem: IDs) {
                /* Вызов исключения в случае повторного ввода ID*/
                if (elem == int_id) throw SyntaxException("The ID is already exist!", 11);
            }
            ptr = IPerson::CreateInstance(int_id); // создание экземпляра с помощью функции фабрики
        } catch (SyntaxException &ex) {
            ex.description(); // обработка исключения
        }
    }
    /* Блок очистки строки, содержащей справочную информацию (если было вызвано исключение)*/
    remember_coursor(); // запомнить положение курсора
    move_cursor(START_ROW_FR - 1, 0); // перемещение курсора в нужную строку
    clear_row(); // очистка строки
    /* Конец блока очистки */

    IDs.push_back(int_id); // добавление очередного ID в контейнер
    ptr->set_id(int_id); // инициализация атрибута _id
    move_cursor(START_ROW + row_to_print * STEP_ROW, current_col += STEP_COL); // перемещение курсора
    ptr->set_surname(); // инициализация атрибута _surname
    move_cursor(START_ROW + row_to_print * STEP_ROW, current_col += STEP_COL); // перемещение курсора
    ptr->set_name(); // инициализация атрибута _name
    move_cursor(START_ROW + row_to_print * STEP_ROW, current_col += STEP_COL); // перемещение курсора
    std::cout << ptr->get_category(); // вывод атрибута _category (инициализирован конструктором класса)
    move_cursor(START_ROW + row_to_print * STEP_ROW, current_col += STEP_COL); // перемещение курсора
    ptr->set_exp(); // инициализация атрибута _exp
    move_cursor(START_ROW + row_to_print * STEP_ROW, current_col); // перемещение курсора
    std::cout << ptr->get_exp();// вывод обработанного атрибута _exp (для наглядности)

    /* Блок очистки строки, содержащей справочную информацию (если было вызвано исключение)*/
    remember_coursor(); // запомнить положение курсора
    move_cursor(START_ROW_FR - 1, 0); // перемещение курсора в нужную строку
    clear_row(); // очистка строки
    /* конец блока очистки */

    move_cursor(START_ROW + row_to_print * STEP_ROW, current_col += STEP_COL); // перемещение курсора
    std::cout << ptr->get_info(); // вывод атрибута _info (инициализирован конструктором класса)
    return ptr; // возврат указателя на инициализированный экземпляр класса производного к IPerson
}

PrsPtr IPerson::ReadInstance(std::fstream &fd) {
    /*****************************************************************************************************************
    * Цель: Чтение из файла данных экземпляра класса.
    * Исходные данные:
    *   fd - поток с файловым дескриптором fd
    * Результат: метод возвращает умный указатель на созданный и инициализированный экземпляр.
    * Вызываемые модули: <fstream>, <iostream>
    * Описание алгоритма:
    *   Методом WriteInstance в файл записаны атрибуты, указатели на которые хрнятся в атрибуте-массиве указателей
    * _attributes_wr. Для каждого атрибута:
    * 1) Объявляется переменная id_size типа для хранения размера массива char*, соответствующего атрибуту _id
    * 2) Из файла считывается размер массива char*, соответствующего атрибуту _id
    * 3) Объявляется переменная ch_id[id_size] для чтения массива считанного размера из файла. Память выделяется в стеке
    * 4) С помощью ch_id производится чтение из потока массива char*, соответствующего атрибуту _id
    * 5) Считанный массив приводится к целочисленному типу с помощью функции std::stoi и записывается в переменную id
    * 6) С помощью защищенного метода CreateInstance с целым значением id  качестве аргумента создается экземпляр
    * необходимого класса, производного от IPerson. Указатель на экземпляр передается переменной ptr.
    * 7) Инициализируется атрибут _id экземпляра ptr.
    * 8) Для каждого атрибута из массива _attributes_wr:
    *   - считывается размер массива типа char* соответствующего значению атрибута
    *   - в стеке объявляется массив считанного размера типа char*
    *   - считывается массив типа char* соответствующий значению атрибута
    *   - в цикле обходятся символы считанного массива, на каждой итерации символ добавляется к значению атрибута
    *   (изначально пустому) с помощью операции конкатенации.
    *   9) Возвращаем указатель на инициализированный экземпляр класса, указанный в файле
    * Дата: 08 / 06 / 2022 Версия 1.01
    * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    * Исправления: нет
    *****************************************************************************************************************/
    std::size_t id_size{0}; // объявляем переменную для считывания размера массива char* (атрибута)
    fd.read((char *) &id_size, sizeof(std::size_t)); // считываем размер
    char ch_id[id_size]; // выделяем память в стеке под будущий массив
    fd.read((char *) &ch_id, long(id_size)); // считываем данные (элементы) массива char* атрибута _id
    int id = std::stoi(ch_id); // приведение к целому типу
    PrsPtr ptr = IPerson::CreateInstance(id); // создание экземпляра с помощью фабрики
    ptr->set_id(id); // инициализация атрибута _id
    for (int i = 1; i < NUMB_OF_ATTR_WR; i++) { // обход записанных атрибутов экземпляра класса с помощью указателей
        std::size_t attr_size{0}; // объявляем переменную для считывания размера массива char* (атрибута)
        fd.read((char *) &attr_size, sizeof(std::size_t)); // считываем размер
        char content[attr_size]; // выделяем память в стеке под будущий массив
        fd.read((char *) &content, long(attr_size)); // считываем данные (элементы) массива char* атрибута
        for (auto &ch: content) { // для каждого считанного символа
            *ptr->get_attr_wr()[i] += ch; // посимвольно копируем данные в атрибут (конкатенация)
        }
    }
    return ptr; // возврат указателя на инициализированный экземпляр класса
}

/**********************************************************************************************************************
*                                                class Person
***********************************************************************************************************************/

Person::Person() = default; // конструктор по умолчанию

Person::~Person() = default; // деструктор по умолчанию

/* Функция инициализации атрибута _surname: с помощью стандартного потока ввода пользователем вводится фамилия */
void Person::set_surname() { std::cin >> _surname; }

/* Функция инициализации атрибута _name: с помощью стандартного потока ввода пользователем вводится имя */
void Person::set_name() { std::cin >> _name; }

/* Функция инициализации атрибута _id: с помощью приведения к целого числа к строковому типу атрибуту присваивается
 * переданное значение аргумента id */
void Person::set_id(int id) { _id = std::to_string(id); }

void Person::set_exp() {
    /*****************************************************************************************************************
   * Цель: инициализация атрибута _exp
   * Результат: атрибут _exp инициализирован строкой, содержащей информацию о курсе обучения или стаже работы человека.
   * Вызываемые модули: "liblibrary.a"
   * Описание алгоритма:
   * 1) Объявляются инициализируются нулевым значением целочисленные переменные:
   *    mark - переменная индикатор завершения бесконечного цикла
    *   check - временная переменная для хранения считанного из stdin значения
   * 2) В бесконечном цикле:
   *    - производится считывание с клавиатуры данных в атрибут _exp;
   *    - производится попытка привести к целому значение атрибута. если попытка не успешна, вызывается соответствующее
   *    исключение класса SyntaxException.
   *    - если попытка успешна, производится проверка принадлежности введенного числа интервалу (0; 100) и обратная
   *    проверка с помощью приведения к строковому типу временной переменной check на равенство атрибуту _exp.
   *    Если введенные данные не соответствуют вышеназванным условиям вызывается соответствующее исключение класса
   *    SyntaxException, иначе переменная-индикатор mark инициализируется значением 1, цикл завершается.
   * Дата: 07 / 06 / 2022 Версия 1.01
   * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
   * Исправления: нет
   *****************************************************************************************************************/
    int mark{0}, check{0};
    while (!mark) {
        try {
            std::cin >> _exp;
            try {
                check = std::stoi(_exp); // попытка привести к целому типу полученного аргумента
            } catch (std::exception &stoi_err) {
                throw SyntaxException("Course/degree must be an integer between 0 and 100", 12);
            }
            if (check <= 0 || check >= 100 || std::to_string(check) != _exp) {
                throw SyntaxException("Course/degree must be an integer between 0 and 100", 12);
            } else mark = 1;
        } catch (SyntaxException &ex) {
            ex.description();
        }
    }
}
/* Функция получения значения атрибута _exp: возвращается указатель на атрибут _exp */
string Person::get_exp() {
    return _exp;
}
/* Функция получения значения атрибута _category: возвращается указатель на атрибут _category */
string Person::get_category() {
    return _category;
}
/* Функция получения значения атрибута _info: возвращается указатель на атрибут _info */
string Person::get_info() {
    return _info;
}
/* Функция получения значения атрибута _attributes_wr: возвращается указатель на атрибут _attributes_wr */
string **Person::get_attr_wr() {
    return _attributes_wr; // возвращение массива указателей на атрибуты подлежащие записи в файл
}

void Person::PrintInstance(int start_row) {
    /*****************************************************************************************************************
    * Цель: Вывод данных экземпляра класса с перемещением курсора во время вывода в соответствующие ячейки таблицы.
    * Исходные данные:
    *   start_row - строка таблицы, в которой должен осуществляться вывод
    * Результат: данные экземпляра класса выведены в соответствующих ячейках таблицы.
    * Вызываемые модули: <iostream>
    * Описание алгоритма:
    * 1) Переменная current_col, соответствующая позиции текущего столбца для вывода, инициализируется
    * начальным значением START_COL
    * 2) Для каждого элемента структуры:
    *   - курсор перемещается в очередную позицию (используются шаги сдвига курсора)
    *   - производится вывод очередного значения элемента структуры
    * Дата: 07 / 06 / 2022 Версия 1.01
    * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    * Исправления: нет
    *****************************************************************************************************************/
    int current_col = START_COL;
    move_cursor(START_ROW + start_row * STEP_ROW, START_COL);
    for (auto &_attribute: _attributes) { // обход аттрибутов объекта через указатели
        std::cout << *_attribute; // вывод
        move_cursor(START_ROW + start_row * STEP_ROW, current_col += STEP_COL); // перемещение курсора
    }
}

void Person::WriteInstance(std::fstream &fd) {
    /*****************************************************************************************************************
    * Цель: Запись атрибутов объекта в файл.
    * Исходные данные:
    *   fd - поток с файловым дескриптором fd
    * Результат: данные атрибутов объекта записаны в файл.
    * Вызываемые модули: <fstream>, <iostream>
    * Описание алгоритма:
    * Все атрибуты объекта имеют тип(класс) string. Для каждого атрибута:
    * 1) С помощью метода get_size() в переменную записывается размер массива символов, содержащихся в значении атрибута
    * 2) В файл записывается полученный размер
    * 3) В файл записывается сам массив, полученный с помощью приведения к C-style строке атрибута
    * Дата: 07 / 06 / 2022 Версия 1.01
    * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    * Исправления: нет
    *******************************************************************************************************************/
    for (auto &_attribute: _attributes_wr) { // обход атрибутов экземпляра класса с помощью указателей
        std::size_t attr_size = strlen(_attribute->c_str()); //узнаем размер
        fd.write((char *) &attr_size, sizeof(std::size_t)); // записываем размер в файл
        fd.write((char *) &*_attribute->c_str(), long(attr_size));  // записываем массив char* полученного размера,
        // соответствующий атрибуту в файл
    }
}

/**********************************************************************************************************************
*                                                class Student
***********************************************************************************************************************/

/* Конструктор класса Student, по умолчанию инициализирует атрибут _category строкой, соответствующей этому классу*/
Student::Student() { _category = "student"; }

Student::~Student() = default; // деструктор по умолчанию

void Student::set_exp() {
    /*****************************************************************************************************************
    * Цель: инициализация атрибута _exp
    * Результат: атрибут _exp инициализирован строкой, содержащей информацию о курсе обучения студента.
    * Вызываемые модули:
    * Описание алгоритма:
    * 1) Вызывается метод set_exp() родительского класса Person - атрибут при этом инициализируется строковым
    * представлением числа, соответствующего курсу обучения студента
    * 2) С помощью операции конкатенации в атрибут добавляется слово course для наглядности отображения данных
    * Дата: 07 / 06 / 2022 Версия 1.01
    * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    * Исправления: нет
    *****************************************************************************************************************/
    Person::set_exp(); // вызов метода родительского класса для предварительной инициализации атрибута
    _exp += " course"; // добавление слова course для наглядности отображения данных
}

/**********************************************************************************************************************
*                                                class Bachelor
***********************************************************************************************************************/

/* Конструктор класса Bachelor, по умолчанию инициализирует атрибут _info строкой, соответствующей этому классу*/
Bachelor::Bachelor() : Student() { _info = "bachelor"; }

Bachelor::~Bachelor() = default; // деструктор по умолчанию

/**********************************************************************************************************************
*                                                class Master
***********************************************************************************************************************/

/* Конструктор класса Master, по умолчанию инициализирует атрибут _info строкой, соответствующей этому классу */
Master::Master() : Student() { _info = "master"; }

Master::~Master() = default; // деструктор по умолчанию

/**********************************************************************************************************************
*                                                class Graduate
***********************************************************************************************************************/

/* Конструктор класса Graduate, по умолчанию инициализирует атрибут _info строкой, соответствующей этому классу */
Graduate::Graduate() : Student() { _info = "graduate"; }

Graduate::~Graduate() = default; // деструктор по умолчанию

/**********************************************************************************************************************
*                                                class Employee
***********************************************************************************************************************/

/* Конструктор класса Employee, по умолчанию инициализирует атрибут _category строкой, соответствующей этому классу */
Employee::Employee() { _category = "employee"; }

Employee::~Employee() = default; // деструктор по умолчанию

void Employee::set_exp() {
    /*****************************************************************************************************************
    * Цель: инициализация атрибута _exp
    * Результат: атрибут _exp инициализирован строкой, содержащей информацию о текущем стаже сотрудника.
    * Вызываемые модули:
    * Описание алгоритма:
    * 1) Вызывается метод set_exp() родительского класса Person - атрибут при этом инициализируется строковым
    * представлением числа, соответствующего курсу обучения студента
    * 2) С помощью операции конкатенации в атрибут добавляется слово 'year' в нужной форме для наглядности отображения
    * данных. С помощью функции приведения строки к целому (std::stoi) тернарным оператором проверяется на равенство
    * единице данные атрибута _exp:
    *   - в случае равенства единице добавляется слово year (в единственном числе);
    *   - иначе добавляется слово years (в множественном числе);
    * Дата: 07 / 06 / 2022 Версия 1.01
    * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    * Исправления: нет
    *****************************************************************************************************************/

    Person::set_exp(); // вызов метода родительского класса для предварительной инициализации атрибута

    /* добавление слова 'year' в нужной форме для наглядности отображения данных о сотруднике */
    _exp += (std::stoi(_exp) == 1 ? " year" : " years");
}

/**********************************************************************************************************************
*                                                class Teacher
***********************************************************************************************************************/

/* Конструктор класса Teacher, по умолчанию инициализирует атрибут _info строкой, соответствующей этому классу*/
Teacher::Teacher() : Employee() { _info = "CST dept"; }

Teacher::~Teacher() = default; // деструктор по умолчанию

/**********************************************************************************************************************
*                                                class Assistant
***********************************************************************************************************************/

/* Конструктор класса Assistant, по умолчанию инициализирует атрибут _info строкой, соответствующей этому классу */
Assistant::Assistant() : Employee() { _info = "Training dept"; }

Assistant::~Assistant() = default; // деструктор по умолчанию

/**********************************************************************************************************************
*                                                class HouseKeeper
***********************************************************************************************************************/

/* Конструктор класса HouseKeeper, по умолчанию инициализирует атрибут _info строкой, соответствующей этому классу */
HouseKeeper::HouseKeeper() : Employee() { _info = "HK service"; }

HouseKeeper::~HouseKeeper() = default; // деструктор по умолчанию
