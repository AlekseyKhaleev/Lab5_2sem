/**********************************************************************************************************************
* Данный модуль содержит описания функций, предназначенных для работы с таблицей (создание, инициализация, вывод)
***********************************************************************************************************************/

/* Подключение модулей */
#include "table_func.h"
#include "definitions.h"
#include "print_func.h"
#include "draw_func.h"
#include "classes.h"
#include <map>
#include <termios.h>
#include <unistd.h>
#include <iostream>

/* Функция вызова исключения связанного с выделением памяти для передачи в set_new_handler() */
void NewError() {
    throw std::bad_alloc();
}

int UserKey() {
    /*****************************************************************************************************************
    * Цель: Считывание кода нажатой клавиши в терминале без промежуточной буферизации
    * Исходные данные:
    * Результат: функция возвращает целое число соответствующее коду нажатой клавиши
    * Вызываемые модули: <termios.h>, <unistd.h>
    * Описание алгоритма:
    * 1) С помощью модуля termios.h объявляются структуры для хранения состояния терминала:
    *       - oldt до считывания нажатия клавиши
    *       - newt во время считывания нажатия клавиши
    * 2) Объявляются целочисленные переменные и массив:
    *   - key_buffer целочисленный массив для хранения кода считанной клавиши (из-за привязки к ESC-последовательностям
    *   управляющие клавиши могут возвращать не единственное целое число (код символа), а серию таких чисел).
    *   Размер массива равен 10, чтобы обеспечить "запас" и избежать обращения по несуществующему индексу.
    *   - buffer_index вспомогательная переменная для обхода массива key_buffer в цикле.
    *   - key_code переменная для хранения обработанного кода считанной клавиши.
    * 3) В структуру oldt записывается текущее состояние терминала, это позволит восстановить исходное состояние
    * терминала после завершения необходимых операций, также состояние дублируется в структуру newt.
    * 4) В структуре newt отключаются флаги "каноничный" и "эхо", это необходимо для обеспечения не каноничного ввода
    * (без буферизации, редактирования).
    * 5) С помощью структуры newt применяется новый режим (состояние) терминала.
    * 6) C помощью функции getchar() считывается нажатие клавиши клавиатуры, результат приводится к типу int
    * и записывается в массив key_buffer под индексом 0.
    * 7) Производится обработка полученного значения:
    *   - если полученное целое значение равно 27, то возможны 2 варианта:
    *     1. Считана клавиша ESC, значение записано в массив.
    *     2. Считана управляющая клавиша, первое число из серии возвращаемых значений записано в массив.
    *   Для определения нажатой клавиши с помощью цикла производится попытка считать все оставшиеся числа серии
    *   и записать их в массив key_buffer. Для продвижения по массиву в цикле используется переменная-индекс
    *   buffer_index, начальное значение которого равно 1. Отличие от 1 индекса после завершения цикла является
    *   маркером считывания управляющей клавиши. В данной программе используются только 2 управляющие клавиши,
    *   не считая ESC: Up и Down, серии возвращаемых значений которых отличаются третьими элементами, равными
    *   соответственно 65 и 66. В связи с этим свойством, в случае отличия от 1 индекса buffer_index в переменную
    *   key_code записывается значение элемента key_buffer с индексом 2. В противном случае записывается значение
    *   элемента key_buffer с индексом 0.
    * 8) С помощью сохраненного в структуре oldt состояния терминала восстанавливаются исходные параметры.
    * 9) Функция возвращает обработанный целочисленный код клавиши, сохраненный в переменной key_code.
    // Дата: 09 / 03 / 2022 Версия 1.01
    // Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    // Исправления: нет
    *****************************************************************************************************************/
    struct termios oldt{}, newt{};                          // структуры для хранения состояния терминала
    int key_code, buffer_index{1}, key_buffer[KEY_BUF_LEN]; // Переменные и массив, необходимые для работы модуля
    tcgetattr(STDIN_FILENO, &oldt);            // Сохранение исходного состояния терминала
    newt = oldt;                                           // Копирование состояния терминала для дальнейшей работы
    newt.c_lflag &= ~(ICANON | ECHO);                      // Отключение флагов "каноничный" и "эхо"
    tcsetattr(STDIN_FILENO, TCSANOW, &newt); // Применение новых параметров терминала
    key_buffer[0] = getchar(); // Считывание нажатия клавиши клавиатуры

    // Блок обработки, проверка на получение управляющей клавиши, сохранение целочисленного кода нажатой клавиши
    if (key_buffer[0] == 27) {
        newt.c_cc[VMIN] = 0;
        tcsetattr(0, TCSANOW, &newt);
        while ((key_buffer[buffer_index] = getchar()) > 0) {
            ++buffer_index;
            if (buffer_index >= KEY_BUF_LEN) break;
        }
        clearerr(stdin);
    }
    if (buffer_index > 1) {
        key_code = key_buffer[2];
    } else
        key_code = key_buffer[0];

    /* Восстановление исходных параметров терминала */
    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
    return key_code; // Возвращение целочисленного кода нажатой клавиши, завершение работы модуля
}


void PrintTable(PrsPtr Persons[], int rows_request, int row_index) {
    /****************************************************************************************************************
    * Цель: Печать указанного количества строк таблицы, начиная с указанной строки
    * Исходные данные:
    *      ParkContent  - массив структур, составляющих парк ПК, каждый элемент массива/структура - строка таблицы
    *      rows_request - запрошенное количество строк для вывода
    *      row_index   - номер строки, с которой начинается вывод
    * Результат: Таблица выведена согласно запроса
    * Вызываемые модули: "lib_classes.h", "definitions.h"
    * Описание алгоритма:
    * 1) С помощью логического выражения определяется необходимое количество строк для вывода. Количество выводимых
    *  строк не может быть больше чем вмещает таблица, отрисованная на экране:
    *  - если запрошенное количество строк на вывод больше максимального, будет выведено максимальное количество строк
    *  Определенное значение присваивается переменной total_rows
    * 2) В цикле с помощью инкремента изменяются значения двух переменных:
    *   i : от 0 до определенного количества строк total_rows (не включительно)
    *   j : от row_index до завершения цикла
    * 3) На каждой итерации цикла для элемента массива структур ParkContent с индексом j осуществляется вызов метода
    * .print с аргументом i. Такая операция приводит к выводу данных ПК с номером [j] в i-той строке таблицы.
    * Дата: 15 / 05 / 2022 Версия 1.01
    * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    * Исправления: нет
    ****************************************************************************************************************/
    int total_rows = rows_request > MAX_ROWS ? MAX_ROWS : rows_request; // количество строк с учетом ограничений
    for (int i = 0, j = row_index; i < total_rows; i++, j++) {
        PrintInstance(Persons[j], i);
    }
}

int CreateTable(char *argv[], std::fstream &table_out, int rows_request) {
    /*******************************************************************************************************************
    * Цель: Запись в бинарный файл данных таблицы, введенных пользователем
    * Исходные данные:
    *      argv          - массив аргументов командной строки, с которыми была запущена программа
    *      table_out     - дескриптор файла для записи введенных данных таблицы
    *      rows_request  - запрошенное количество строк для записи (Также содержится в массиве аргументов argv, но
    *      в виде С-строки. Так как тип уже приводится к int в процессе обработки корректности аргументов, целесообразно
    *      использовать приведенное значение, для избежания дублирования кода)
    * Результат:
    *   - введены и записаны в бинарный файл данные таблицы
    *   - функция возвращает номер первой значащей строки, отображаемой в данный момент (порядковый номер ПК)
    * Вызываемые модули: "lib_classes.h", "definitions.h", "draw_func.h", "print_func.h", <fstream>
    * Описание алгоритма:
    * 1) С помощью функции CustomizeTerminal применяются новые настройки терминала, необходимые для корректной работы
    * программы
    * 2) С помощью функции PrintHeader выводится заголовок отображаемой страницы
    * 3) С помощью функции DrawTable выводится пустой шаблон таблицы
    * 4) Применяются настройки для отлавливания ошибок, связанных с выделением памяти
    * 5) Объявляется и инициализируется начальным значением 0 переменная row_index, соответствующая индексу в массиве
    * первой значащей строки, отображаемой в данный момент (порядковый номер ПК)
    * 6) В файл, соответствующий дескриптору table_out специальный код программы необходимый для последующей
    * идентификации в режиме чтения
    * 7) В файл записывается количество строк (rows_request), которые будут записаны
    * 8) Выделяется память для массива экземпляров класса PC размером rows_request, указатель на память - ParkUpdate
    * 9) В цикле изменяется целочисленная переменная i, соответствующая индексу записываемой строки от 0 до rows_request
    * (не включительно) с шагом 1. В цикле реализована визуальная "прокрутка" уже введенных данных.
    * На каждой итерации цикла:
    *   Если  i меньше максимального количества отображаемых строк (пока ввод осуществляется не в последней строке
    *   отображаемой на экране таблицы):
    *      - с помощью метода ParkUpdate[i].set() осуществляется ввод значений очередного экземпляра класса
    *   (строки) в соответствующей строке таблицы.
    *      - с помощью метода ParkUpdate[i].write() инициализированный экземпляр класса записывается в двоичный файл
    *   Если достигнута последняя строка:
    *       - заново рисуется пустой шаблон таблицы
    *       - с помощью функции PrintTable() строки таблицы, кроме последней, заполняются элементами массива ParkUpdate,
    *       начиная с индекса row_index и заканчивая i-1, так как i соответствует не инициализированному аргументу.
    *       - с помощью метода ParkUpdate[i].set() осуществляется ввод значений очередного экземпляра класса
    *   (строки) в последней строке таблицы.
    *       - с помощью метода ParkUpdate[i].write() инициализированный экземпляр класса записывается в двоичный файл
    *       - переменная row_index, соответствующая номеру первой значащей строки, отображаемой в данный момент
    *       (порядковый номер ПК) увеличивается на 1.
    * Дата: 23 / 05 / 2022 Версия 1.01
    * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    * Исправления: нет
    *******************************************************************************************************************/

    CustomizeTerminal(F_BLACK, B_WHITE); // применение новых настроек терминала
    PrintHeader(argv);                             // печать заголовка
    DrawTable();                                   // вывод пустого шаблона таблицы
    errno = 0;  // Переменная модуля errno.h, хранящая целочисленный код последней ошибки. 0 - отсутствие ошибок
    std::set_new_handler(NewError); // Назначение функции, которая будет вызвана при получении ошибки выделения памяти
    int row_index = 0;                            // индекс в массиве PC первой значащей строки, отображаемой в данный момент
    try {
        table_out.write((char *) &CORRECT_BIT, sizeof(CORRECT_BIT)); // запись специального кода программы
        table_out.write((char *) &rows_request, sizeof(int));        // запись количества строк в таблице
        PrsPtr Persons[rows_request];    // выделение памятиh
        for (int i = 0; i < rows_request; i++) {
            if (i < MAX_ROWS)
                /* Если не достигнута последняя строка в отображаемой таблице */
            {
                InitInstance(Persons[i], i); // ввод данных в соответствующих ячейках
                WriteInstance(Persons[i], table_out); // запись экземпляра класса в файл
            } else
                /* Если достигнута последняя строка в отображаемой таблице */
            {
                row_index++; // увеличение на 1 индекса в массиве PC первой отображаемой записи
                DrawTable(); // вывод пустого шаблона таблицы
                /* Заполнение таблицы до предпоследней строки включительно */
                PrintTable(Persons, MAX_ROWS-1, row_index);
                /* Инициализация очередного экземпляра класса, курсор ввода в последней строке */
                InitInstance(Persons[i], MAX_ROWS - 1);
                WriteInstance(Persons[i],table_out); // запись экземпляра класса в файл
            }
        }
    } catch (std::exception &e) { // Обработка исключения, связанного с выделением динамической памяти
        perror("Memory allocation error");
    }
    return row_index; // возвращаем номер первой отображаемой записи
}

void ViewTable(char *argv[], std::fstream &table_in, int rows_request, int row_index) {
    /*******************************************************************************************************************
    * Цель: Просмотр таблицы, с поддержкой управляющих клавиш
    * Исходные данные:
    *      argv         - массив аргументов командной строки, с которыми была запущена программа
    *      table_in     - дескриптор файла, содержащего данные таблицы
    *      rows_request - запрошенное количество строк для чтения (Также содержится в массиве аргументов argv, но
    *      в виде С-строки. Так как тип уже приводится к int в процессе обработки корректности аргументов, целесообразно
    *      использовать приведенное значение, для избежания дублирования кода)
    *      row_index    - индекс первой записи в таблице
    * Результат в зависимости от полученных управляющих клавиш:
    *   - просмотр таблицы
    *   - прокрутка данных внутри таблицы
    *   - просмотр ──────────────┐
     │1               справки
    *   - завершение работы программы
    * Вызываемые модули: "lib_classes.h", "definitions.h", "draw_func.h", "print_func.h" <fstream>
    * Описание алгоритма:
    * 1) Применяются настройки для отлавливания ошибок, связанных с выделением памяти
    * 2) Объявляется переменная real_rows, предназначенная для хранения количества записей/структур в файле
    * 3) Указатель в файле перемещается в позицию, соответствующую количеству записей.
    * 4) Количество содержащихся в файле записей считывается в переменную real_rows
    * 5) Объявляется переменная rows_to_print, соответствующая количеству строк, которые будут выведены, с помощью
    * логического оператора ей присваивается значение:
    *   - если запрошенное количество строк(rows_request) меньше реально содержащегося в файле, присваивается запрошенное
    *   значение
    *   - иначе присваивается значение, соответствующее реально содержащемуся количеству записей(строк).
    * 6) Выделяется память для массива экземпляров класса PC размером rows_to_print, указатель на память - ParkContent
    * 7) В цикле осуществляется чтение данных из файла и инициализация ими элементов массива ParkContent
    * 8) Выводится страница программы, содержащая таблицу и связанную с ней информацию
    * 9) В бесконечном цикле реализуется поддержка управляющих клавиш:
    *   h: вызов справки
    *   r: возврат к основной странице из режима справки
    *   up/down: прокрутка данных внутри таблицы вверх/вниз
    *   esc: завершение работы программы
    * Дата: 15 / 05 / 2022 Версия 1.01
    * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    * Исправления: нет
    *******************************************************************************************************************/
    errno = 0;  // Переменная модуля errno.h, хранящая целочисленный код последней ошибки. 0 - отсутствие ошибок
    std::set_new_handler(NewError); // Назначение функции, которая будет вызвана при получении ошибки выделения памяти
    try {
        int real_rows; // действительное количество строк
        table_in.seekg(sizeof(CORRECT_BIT)); // перемещение курсора в файле в позицию после специального кода программы
        table_in.read((char *) &real_rows, sizeof(int)); // чтение количества записей в файле
        int rows_to_print = rows_request < real_rows? rows_request:real_rows; // определение количества строк для вывода
        PrsPtr Persons[rows_to_print]; // выделение памяти
        for (int i = 0; i < rows_to_print; i++) {
            ReadInstance(Persons[i],table_in); // чтение данных таблицы в массив экземпляров класса PC
        }
        GenerateTablePage(Persons, argv, rows_to_print, real_rows, row_index); // вывод основной страницы программы
        int mark = true; // флаг-индикатор продолжения/завершения программы
        while (mark) { // бесконечный цикл считывания клавиш
            switch (UserKey()) { // считывание кода клавиши введенной пользователем в режиме "реального времени"
                /* Клавиша ESC завершит цикл считывания клавиш */
                case Escape: {
                    mark = false;
                    break;
                }
                    /* Клавиша Up прокрутит данные внутри таблицы на 1 строку вверх */
                case Up: {
                    if (row_index > 0) { // если таблица отображена не сначала
                        row_index--;     // уменьшаем номер первой записи
                        /* вывод основной страницы программы */
                        GenerateTablePage(Persons, argv, rows_to_print, real_rows, row_index);
                    }
                    break;
                }
                    /* Клавиша Down прокрутит данные внутри таблицы на 1 строку вниз */
                case Down: {
                    /* если таблица отображена не до конца, и считано строк больше чем можно отобразить за раз */
                    if ((row_index <= rows_to_print - MAX_ROWS_FR) && (rows_to_print > MAX_ROWS_FR)) {
                        row_index++; // увеличиваем номер первой записи
                        /* вывод основной страницы программы */
                        GenerateTablePage(Persons, argv, rows_to_print, real_rows, row_index);
                    }
                    break;
                }
                    /* Клавиша h вызовет справочную страницу */
                case Help: {
                    PrintHelpScreen("help_prog"); // Вывод справочного экрана
                    int h_mark = true; // флаг-индикатор продолжения/завершения показа справочного экрана
                    while (h_mark) { // бесконечный цикл считывания клавиш
                        switch (UserKey()) {
                            /* Клавиша ESC завершит цикл считывания клавиш как в режиме справки, так и в основном цикле
                             * и приведет в последствии к завершению программы*/
                            case Escape: {
                                h_mark = false;
                                mark = false;
                                break;
                            }
                                /* Клавиша r завершит цикл считывания клавиш в режиме справки, просмотр текста продолжится
                                * с экрана на котором была вызвана справка */
                            case Return: {
                                GenerateTablePage(Persons, argv, rows_to_print, real_rows, row_index);
                                h_mark = false;
                                break;
                            }
                            default:
                                break;  // игнорирование любых клавиш, поведение которых неопределено
                        }
                    }
                    break;
                }
            }
        }
    } catch (std::exception &e) { // Обработка исключения, связанного с выделением динамической памяти
        perror("Memory allocation error");
    }
}

void GenerateTablePage(PrsPtr Persons[], char* argv[], int rows_to_print, int real_rows, int row_index){
    /*******************************************************************************************************************
    * Цель: Вывод страницы с таблицей
    * Исходные данные:
    *      ParkContent   - массив экземпляров класса PC, содержащий данные таблицы
    *      argv          - массив аргументов командной строки, с которыми была запущена программа
    *      rows_to_print - количество строк для вывода
    *      real_rows     - количество строк в файле
    *      row_index    - номер первой записи в таблице
    * Результат: Выведена основная страница программы с таблицей
    * Вызываемые модули: "lib_classes.h", "definitions.h", "draw_func.h", "print_func.h", <fstream>
    * Описание алгоритма:
    * 1) Применяются настройки терминала, необходимые для корректной работы программы
    * 2) Вывод заголовка текущей страницы
    * 3) Вывод шаблона страницы
    * 4) Заполнение строк таблицы
    * 5) Вывод результата работы программы в нижней части экрана
    * Дата: 23 / 05 / 2022 Версия 1.01
    * Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
    * Исправления: нет
    *******************************************************************************************************************/
    CustomizeTerminal(F_BLACK, B_WHITE);                  // Применяются новые настройки терминала
    PrintHeader(argv);                                              // Вывод заголовка текущей страницы
    DrawTable();                                                    // Вывод шаблона страницы
    PrintTable(Persons, rows_to_print, row_index); // Заполнение строк таблицы
    PrintFooter(argv, rows_to_print,real_rows);         // Вывод результата работы программы
}
